"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
from typing import Any

"""
Signal types and data structures for SignalCore.

Signals are quantitative assessments, not direct trading orders.
They represent probabilistic predictions that RiskGuard validates.
"""
class SignalType(Enum):
    """Type of trading signal."""
    ENTRY = ...
    EXIT = ...
    SCALE = ...
    HOLD = ...


class Direction(Enum):
    """Trade direction."""
    LONG = ...
    SHORT = ...
    NEUTRAL = ...


@dataclass
class Signal:
    """
    Quantitative signal output from SignalCore.

    Signals are NOT direct orders - they are probabilistic assessments
    that must pass through RiskGuard before becoming executable orders.

    Attributes:
        symbol: Stock ticker symbol
        timestamp: When signal was generated
        signal_type: Entry, exit, scale, or hold
        direction: Long, short, or neutral

        # Quantitative outputs
        probability: Probability of favorable outcome (0.0 to 1.0)
        expected_return: Point estimate of expected return
        confidence_interval: (lower, upper) bounds on expected return
        score: Composite signal strength (-1.0 to +1.0)

        # Model attribution
        model_id: Identifier of generating model
        model_version: Model version string
        feature_contributions: Feature importance for explainability

        # Metadata
        regime: Current detected market regime
        data_quality: Input data quality score (0.0 to 1.0)
        staleness: Age of underlying data
        metadata: Additional model-specific data
    """
    symbol: str
    timestamp: datetime
    signal_type: SignalType
    direction: Direction
    probability: float = ...
    expected_return: float = ...
    confidence_interval: tuple[float, float] = ...
    score: float = ...
    model_id: str = ...
    model_version: str = ...
    feature_contributions: dict[str, float] = ...
    regime: str = ...
    data_quality: float = ...
    staleness: timedelta = ...
    metadata: dict[str, Any] = ...
    price: float | None = ...
    confidence: float | None = ...
    def __post_init__(self): # -> None:
        """Validate signal data."""
        ...
    
    def is_actionable(self, min_probability: float = ..., min_score: float = ...) -> bool:
        """
        Check if signal meets minimum thresholds for action.

        Args:
            min_probability: Minimum probability threshold
            min_score: Minimum absolute score threshold

        Returns:
            True if signal is actionable
        """
        ...
    
    def to_dict(self) -> dict[str, Any]:
        """Convert signal to dictionary."""
        ...
    


@dataclass
class SignalBatch:
    """
    Collection of signals for portfolio-level decisions.

    Attributes:
        timestamp: Batch generation time
        signals: List of individual signals
        universe: Symbols in current trading universe
        regime_state: Current market regime information
        portfolio_context: Portfolio state and constraints
    """
    timestamp: datetime
    signals: list[Signal]
    universe: list[str]
    regime_state: dict[str, Any] = ...
    portfolio_context: dict[str, Any] = ...
    def filter_actionable(self, min_probability: float = ..., min_score: float = ...) -> list[Signal]:
        """
        Filter to only actionable signals.

        Args:
            min_probability: Minimum probability threshold
            min_score: Minimum absolute score threshold

        Returns:
            List of actionable signals
        """
        ...
    
    def get_by_symbol(self, symbol: str) -> Signal | None:
        """Get signal for specific symbol."""
        ...
    
    def get_entry_signals(self) -> list[Signal]:
        """Get all entry signals."""
        ...
    
    def get_exit_signals(self) -> list[Signal]:
        """Get all exit signals."""
        ...
    
    def to_dict(self) -> dict[str, Any]:
        """Convert batch to dictionary."""
        ...
    


