"""
This type stub file was generated by pyright.
"""

import pandas as pd
from dataclasses import dataclass
from enum import Enum, IntEnum

"""
Standalone quantitative finance functions adapted from Goldman Sachs' gs-quant library.

This module provides production-grade timeseries analytics without requiring GS API
credentials. Functions are adapted from gs-quant (Apache 2.0 license) with dependencies
on GS-specific APIs removed.

Original source: https://github.com/goldmansachs/gs-quant
License: Apache 2.0

Usage:
    from ordinis.quant.gs_quant_adapter import (
        moving_average, bollinger_bands, rsi, macd, volatility, sharpe_ratio,
        returns, max_drawdown, correlation, beta, zscores
    )
"""
class Returns(Enum):
    """Return calculation method."""
    SIMPLE = ...
    LOGARITHMIC = ...
    ABSOLUTE = ...


class AnnualizationFactor(IntEnum):
    """Trading day conventions for annualization."""
    DAILY = ...
    WEEKLY = ...
    SEMI_MONTHLY = ...
    MONTHLY = ...
    QUARTERLY = ...
    ANNUALLY = ...


@dataclass
class Window:
    """
    Rolling window specification with optional ramp-up period.

    Args:
        w: Window size (int for observations, str for time period like '22d', '1m')
        r: Ramp-up value (defaults to window size). Results during ramp-up are NaN.

    Examples:
        >>> Window(22, 10)  # 22-day window, 10-day ramp
        >>> Window('1m', '1w')  # 1 month window, 1 week ramp
    """
    w: int | str | pd.DateOffset | None = ...
    r: int | str | pd.DateOffset | None = ...
    def __post_init__(self) -> None:
        ...
    


def returns(series: pd.Series, obs: int = ..., return_type: Returns = ...) -> pd.Series:
    """
    Calculate returns from price series.

    Args:
        series: Time series of prices
        obs: Number of observations for return calculation (default: 1)
        return_type: Return calculation method (simple, logarithmic, absolute)

    Returns:
        Series of returns

    Examples:
        >>> prices = pd.Series([100, 102, 101, 105])
        >>> returns(prices)  # Simple returns
        >>> returns(prices, return_type=Returns.LOGARITHMIC)  # Log returns
    """
    ...

def prices(series: pd.Series, initial: float = ..., return_type: Returns = ...) -> pd.Series:
    """
    Calculate price levels from returns series.

    Args:
        series: Time series of returns
        initial: Initial price level (default: 1.0)
        return_type: Return type of input series

    Returns:
        Series of price levels
    """
    ...

def moving_average(x: pd.Series, w: Window | int | str = ...) -> pd.Series:
    """
    Simple moving average over specified window.

    Args:
        x: Time series of prices
        w: Window size (int, str like '22d', or Window object)

    Returns:
        Series of moving average values

    Examples:
        >>> prices = generate_series(100)
        >>> moving_average(prices, 22)  # 22-day SMA
    """
    ...

def exponential_moving_average(x: pd.Series, span: int | None = ..., alpha: float | None = ...) -> pd.Series:
    """
    Exponentially weighted moving average.

    Args:
        x: Time series of prices
        span: Span for EMA calculation (mutually exclusive with alpha)
        alpha: Smoothing factor (mutually exclusive with span)

    Returns:
        Series of EMA values

    Notes:
        Either span or alpha must be provided. span=N is equivalent to alpha=2/(N+1).
    """
    ...

def bollinger_bands(x: pd.Series, w: Window | int | str = ..., k: float = ...) -> pd.DataFrame:
    """
    Bollinger Bands with given window and width.

    Args:
        x: Time series of prices
        w: Window size for moving average and standard deviation
        k: Number of standard deviations for band width (default: 2)

    Returns:
        DataFrame with columns ['lower', 'middle', 'upper']

    Examples:
        >>> prices = generate_series(100)
        >>> bb = bollinger_bands(prices, 20, 2)
        >>> bb['upper'], bb['lower']
    """
    ...

def rsi(x: pd.Series, w: Window | int | str = ...) -> pd.Series:
    """
    Relative Strength Index (RSI).

    Args:
        x: Time series of prices
        w: Window size (default: 14)

    Returns:
        Series of RSI values (0-100)

    Notes:
        RSI = 100 - (100 / (1 + RS)) where RS = avg_gain / avg_loss
    """
    ...

def macd(x: pd.Series, fast: int = ..., slow: int = ..., signal: int = ...) -> pd.DataFrame:
    """
    Moving Average Convergence Divergence (MACD).

    Args:
        x: Time series of prices
        fast: Fast EMA period (default: 12)
        slow: Slow EMA period (default: 26)
        signal: Signal line EMA period (default: 9)

    Returns:
        DataFrame with columns ['macd', 'signal', 'histogram']

    Examples:
        >>> prices = generate_series(100)
        >>> result = macd(prices)
        >>> result['histogram']  # MACD histogram for trend signals
    """
    ...

def volatility(x: pd.Series, w: Window | int | str = ..., returns_type: Returns | None = ..., annualization_factor: int | None = ...) -> pd.Series:
    """
    Realized volatility of price or return series.

    Args:
        x: Time series of prices or returns
        w: Window size
        returns_type: Return calculation method. If None, x is assumed to be returns.
        annualization_factor: Override auto-detected factor (252 for daily, etc.)

    Returns:
        Annualized volatility series (as percentage, e.g., 20.0 for 20%)

    Examples:
        >>> prices = generate_series(100)
        >>> vol = volatility(prices, 22)  # 22-day rolling volatility
    """
    ...

def sharpe_ratio(x: pd.Series, risk_free_rate: float = ..., w: Window | int | str | None = ..., annualization_factor: int | None = ...) -> pd.Series | float:
    """
    Rolling or full-period Sharpe ratio.

    Args:
        x: Time series of prices
        risk_free_rate: Annual risk-free rate (default: 0)
        w: Window size. If None, calculates over full series.
        annualization_factor: Override auto-detected factor

    Returns:
        Sharpe ratio (series if window provided, scalar if full-period)

    Notes:
        Sharpe = (annualized_return - risk_free_rate) / annualized_volatility
    """
    ...

def max_drawdown(x: pd.Series, w: Window | int | str | None = ...) -> pd.Series:
    """
    Maximum peak-to-trough drawdown.

    Args:
        x: Time series of prices
        w: Window size. If None, uses expanding window.

    Returns:
        Drawdown as negative ratio (e.g., -0.2 for 20% drawdown)

    Examples:
        >>> prices = generate_series(100)
        >>> dd = max_drawdown(prices, 22)
    """
    ...

def correlation(x: pd.Series, y: pd.Series, w: Window | int | str = ...) -> pd.Series:
    """
    Rolling correlation between two price series.

    Args:
        x: First price series
        y: Second price series
        w: Window size

    Returns:
        Rolling correlation series (-1 to 1)
    """
    ...

def beta(x: pd.Series, benchmark: pd.Series, w: Window | int | str = ...) -> pd.Series:
    """
    Rolling beta of asset vs benchmark.

    Args:
        x: Asset price series
        benchmark: Benchmark price series
        w: Window size

    Returns:
        Rolling beta series

    Notes:
        Beta = Cov(asset, benchmark) / Var(benchmark)
    """
    ...

def zscores(x: pd.Series, w: Window | int | str | None = ...) -> pd.Series:
    """
    Rolling z-scores over given window.

    Args:
        x: Time series
        w: Window size. If None, uses full series mean and std.

    Returns:
        Z-score series (standardized values)

    Notes:
        Z = (x - mean) / std
    """
    ...

def percentiles(x: pd.Series, w: Window | int | str | None = ...) -> pd.Series:
    """
    Rolling percentile rank of each value.

    Args:
        x: Time series
        w: Window size. If None, uses full series.

    Returns:
        Percentile rank series (0-100)
    """
    ...

def rolling_std(x: pd.Series, w: Window | int | str = ...) -> pd.Series:
    """
    Rolling standard deviation.

    Args:
        x: Time series
        w: Window size

    Returns:
        Rolling standard deviation series
    """
    ...

def rolling_mean(x: pd.Series, w: Window | int | str = ...) -> pd.Series:
    """
    Rolling mean.

    Args:
        x: Time series
        w: Window size

    Returns:
        Rolling mean series
    """
    ...

def rolling_min(x: pd.Series, w: Window | int | str = ...) -> pd.Series:
    """
    Rolling minimum.

    Args:
        x: Time series
        w: Window size

    Returns:
        Rolling minimum series
    """
    ...

def rolling_max(x: pd.Series, w: Window | int | str = ...) -> pd.Series:
    """
    Rolling maximum.

    Args:
        x: Time series
        w: Window size

    Returns:
        Rolling maximum series
    """
    ...

def generate_series(length: int = ..., start_price: float = ..., daily_volatility: float = ..., seed: int | None = ...) -> pd.Series:
    """
    Generate synthetic price series for testing.

    Args:
        length: Number of observations
        start_price: Starting price
        daily_volatility: Daily return volatility
        seed: Random seed for reproducibility

    Returns:
        Series with DatetimeIndex and synthetic prices
    """
    ...

__all__ = ["Returns", "Window", "AnnualizationFactor", "returns", "prices", "moving_average", "exponential_moving_average", "bollinger_bands", "rsi", "macd", "volatility", "sharpe_ratio", "max_drawdown", "correlation", "beta", "zscores", "percentiles", "rolling_std", "rolling_mean", "rolling_min", "rolling_max", "generate_series"]
