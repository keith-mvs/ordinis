#!/usr/bin/env python
"""
Ordinis Demo v0.51 - Consolidated Live Paper Trading System with Enhanced Strategy Alignment

Combines all features from multiple trading scripts:
- Advanced multi-file logging system
- Real-time position management for existing holdings
- ATR-Optimized RSI strategy with adaptive parameters
- Full Massive/Polygon WebSocket streaming
- Comprehensive risk management
- Performance analytics and reporting
- Session archiving

Usage:
    python scripts/trading/ordinis-demo-v050.py

Environment Variables:
    MASSIVE_API_KEY: Massive/Polygon API key for market data
    APCA_API_KEY_ID: Alpaca API key
    APCA_API_SECRET_KEY: Alpaca secret key

Version History:
    v0.50 - Initial consolidated version combining all live trading features
    v0.51 - Added proper StrategyLoader integration, configurable ATR scaling, documented behaviors
"""

from __future__ import annotations

import asyncio
from collections import defaultdict
from datetime import UTC, datetime, timedelta
from decimal import Decimal
import json
import logging
import os
from pathlib import Path
import sys
from typing import Any, Dict, List, Optional, Tuple
import warnings

import pandas as pd
import yaml

# Suppress TensorFlow warnings
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
warnings.filterwarnings('ignore', category=FutureWarning)
warnings.filterwarnings('ignore', category=DeprecationWarning)

sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))

from ordinis.adapters.broker import AlpacaBroker, OrderSide, OrderType
from ordinis.adapters.streaming.massive_stream import MassiveStreamManager
from ordinis.adapters.streaming.stream_protocol import (
    CallbackStreamHandler,
    StreamBar,
    StreamConfig,
    StreamQuote,
    StreamStatus,
)
from ordinis.engines.signalcore.features.technical import TechnicalIndicators
from ordinis.engines.signalcore.strategy_loader import StrategyLoader


# ============================================================================
# ADVANCED LOGGING SYSTEM
# ============================================================================

class LoggingManager:
    """Centralized logging management with multiple specialized loggers."""

    def __init__(self):
        self.log_dir = Path("logs")
        self.log_dir.mkdir(exist_ok=True)

        # Create session archive
        self.timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.archive_dir = self.log_dir / f"session_{self.timestamp}"
        self.archive_dir.mkdir(exist_ok=True)

        self.loggers = self._setup_loggers()

    def _setup_loggers(self) -> Dict[str, logging.Logger]:
        """Initialize all specialized loggers."""

        # Main formatter
        main_formatter = logging.Formatter(
            "%(asctime)s | %(levelname)-7s | %(name)s | %(message)s",
            datefmt="%Y-%m-%d %H:%M:%S"
        )

        # Configure root logger
        logging.basicConfig(
            level=logging.INFO,
            format="%(asctime)s | %(levelname)-7s | %(name)s | %(message)s",
            handlers=[
                logging.StreamHandler(),
                logging.FileHandler(self.log_dir / "ordinis_demo_v051.log"),
                logging.FileHandler(self.archive_dir / "main.log"),
            ],
        )

        loggers = {}

        # Logger configurations
        logger_configs = {
            "trades": "All trade executions and order details",
            "signals": "Trading signals generated by strategies",
            "positions": "Position tracking and P&L updates",
            "performance": "Performance metrics and statistics",
            "market_data": "Market data flow and bar processing",
            "risk": "Risk management decisions and violations",
            "errors": "Errors and exceptions",
            "audit": "Detailed audit trail",
            "session": "Session lifecycle events",
        }

        for name, description in logger_configs.items():
            logger = logging.getLogger(name)

            # Main log file
            handler = logging.FileHandler(self.log_dir / f"{name}.log")
            handler.setFormatter(logging.Formatter("%(asctime)s | %(message)s"))
            logger.addHandler(handler)

            # Archive log file
            archive_handler = logging.FileHandler(self.archive_dir / f"{name}.log")
            archive_handler.setFormatter(logging.Formatter("%(asctime)s | %(message)s"))
            logger.addHandler(archive_handler)

            logger.setLevel(logging.INFO)
            logger.propagate = False

            loggers[name] = logger

        # Special handling for errors logger
        loggers["errors"].setLevel(logging.ERROR)

        # Main logger
        loggers["main"] = logging.getLogger("ordinis_demo")

        return loggers

    def log_session_start(self):
        """Log session start information."""
        self.loggers["session"].info("=" * 80)
        self.loggers["session"].info("ORDINIS DEMO v0.51 - SESSION START")
        self.loggers["session"].info("=" * 80)
        self.loggers["session"].info(f"Timestamp: {self.timestamp}")
        self.loggers["session"].info(f"Archive Directory: {self.archive_dir}")
        self.loggers["session"].info(f"Log Directory: {self.log_dir}")

        # Log environment
        env_vars = ["MASSIVE_API_KEY", "APCA_API_KEY_ID", "APCA_API_SECRET_KEY"]
        for var in env_vars:
            value = os.environ.get(var)
            if value:
                masked = f"{value[:4]}...{value[-4:]}" if len(value) > 8 else "[SET]"
                self.loggers["session"].info(f"{var}: {masked}")
            else:
                self.loggers["session"].info(f"{var}: [NOT SET]")

    def get(self, name: str) -> logging.Logger:
        """Get a specific logger by name."""
        return self.loggers.get(name, self.loggers["main"])


# ============================================================================
# POSITION TRACKING AND MANAGEMENT
# ============================================================================

class PositionTracker:
    """Advanced position tracking with detailed analytics."""

    def __init__(self, log_manager: LoggingManager):
        self.positions: Dict[str, Dict[str, Any]] = {}
        self.closed_positions: List[Dict[str, Any]] = []
        self.log = log_manager
        self.initial_positions: Dict[str, Dict[str, Any]] = {}

    def load_existing_position(self, symbol: str, quantity: int, avg_price: float,
                              current_price: float, market_value: float) -> None:
        """Load an existing position from broker."""
        # Estimate ATR-based stops (2% ATR estimate)
        atr_estimate = current_price * 0.02
        stop_loss = avg_price - (atr_estimate * 1.5)
        take_profit = avg_price + (atr_estimate * 2.0)

        self.positions[symbol] = {
            "symbol": symbol,
            "quantity": quantity,
            "entry_price": avg_price,
            "entry_time": datetime.now(UTC),
            "stop_loss": stop_loss,
            "take_profit": take_profit,
            "reason": "EXISTING_POSITION",
            "current_price": current_price,
            "market_value": market_value,
            "unrealized_pnl": (current_price - avg_price) * quantity,
            "unrealized_pnl_pct": ((current_price - avg_price) / avg_price) * 100,
            "high_water_mark": current_price,
            "max_drawdown": 0.0,
            "bars_held": 0,
            "is_existing": True,
        }

        self.initial_positions[symbol] = self.positions[symbol].copy()

        self.log.get("positions").info(
            f"LOADED | {symbol} | {quantity} shares @ ${avg_price:.2f} | "
            f"Current: ${current_price:.2f} | Value: ${market_value:.2f}"
        )

    def add_new_position(self, symbol: str, quantity: int, entry_price: float,
                        stop_loss: float, take_profit: float, reason: str) -> None:
        """Add a new position opened during this session."""
        self.positions[symbol] = {
            "symbol": symbol,
            "quantity": quantity,
            "entry_price": entry_price,
            "entry_time": datetime.now(UTC),
            "stop_loss": stop_loss,
            "take_profit": take_profit,
            "reason": reason,
            "current_price": entry_price,
            "unrealized_pnl": 0.0,
            "unrealized_pnl_pct": 0.0,
            "high_water_mark": entry_price,
            "max_drawdown": 0.0,
            "bars_held": 0,
            "is_existing": False,
        }

        self.log.get("positions").info(
            f"OPENED | {symbol} | {quantity} shares @ ${entry_price:.2f} | "
            f"SL: ${stop_loss:.2f} | TP: ${take_profit:.2f} | Reason: {reason}"
        )

    def update(self, symbol: str, current_price: float, volume: int = 0) -> Optional[str]:
        """Update position and check for exit signals."""
        if symbol not in self.positions:
            return None

        pos = self.positions[symbol]
        pos["current_price"] = current_price
        pos["bars_held"] += 1

        # Calculate metrics
        entry = pos["entry_price"]
        qty = pos["quantity"]
        pos["unrealized_pnl"] = (current_price - entry) * qty
        pos["unrealized_pnl_pct"] = ((current_price - entry) / entry) * 100

        # Track high water mark
        if current_price > pos["high_water_mark"]:
            pos["high_water_mark"] = current_price

        pos["max_drawdown"] = ((pos["high_water_mark"] - current_price) / pos["high_water_mark"]) * 100

        # Check exit conditions
        exit_signal = None
        if current_price <= pos["stop_loss"]:
            exit_signal = "STOP_LOSS"
        elif current_price >= pos["take_profit"]:
            exit_signal = "TAKE_PROFIT"
        # REMOVED: Undocumented 5% trailing stop not in strategy specification

        # Log significant P&L changes
        if abs(pos["unrealized_pnl_pct"]) > 1.0 and pos["bars_held"] % 10 == 0:
            self.log.get("positions").info(
                f"UPDATE | {symbol} | Price: ${current_price:.2f} | "
                f"P&L: ${pos['unrealized_pnl']:.2f} ({pos['unrealized_pnl_pct']:.1f}%) | "
                f"Drawdown: {pos['max_drawdown']:.1f}%"
            )

        return exit_signal

    def close(self, symbol: str, exit_price: float, exit_reason: str) -> Dict[str, Any]:
        """Close position and record final metrics."""
        if symbol not in self.positions:
            return {}

        pos = self.positions[symbol]
        pos["exit_price"] = exit_price
        pos["exit_time"] = datetime.now(UTC)
        pos["exit_reason"] = exit_reason
        pos["realized_pnl"] = (exit_price - pos["entry_price"]) * pos["quantity"]
        pos["realized_pnl_pct"] = ((exit_price - pos["entry_price"]) / pos["entry_price"]) * 100
        pos["hold_duration"] = (pos["exit_time"] - pos["entry_time"]).total_seconds() / 60

        self.closed_positions.append(pos)
        del self.positions[symbol]

        self.log.get("positions").info(
            f"CLOSED | {symbol} | Exit: ${exit_price:.2f} | "
            f"P&L: ${pos['realized_pnl']:.2f} ({pos['realized_pnl_pct']:.1f}%) | "
            f"Duration: {pos['hold_duration']:.1f} min | Reason: {exit_reason}"
        )

        self.log.get("trades").info(
            f"TRADE COMPLETE | {symbol} | Entry: ${pos['entry_price']:.2f} -> Exit: ${exit_price:.2f} | "
            f"P&L: ${pos['realized_pnl']:.2f} ({pos['realized_pnl_pct']:.1f}%)"
        )

        return pos

    def get_metrics(self) -> Dict[str, Any]:
        """Calculate portfolio-wide metrics."""
        total_unrealized = sum(p["unrealized_pnl"] for p in self.positions.values())
        total_realized = sum(p["realized_pnl"] for p in self.closed_positions)

        wins = [p for p in self.closed_positions if p["realized_pnl"] > 0]
        losses = [p for p in self.closed_positions if p["realized_pnl"] <= 0]

        return {
            "open_positions": len(self.positions),
            "closed_trades": len(self.closed_positions),
            "total_unrealized_pnl": total_unrealized,
            "total_realized_pnl": total_realized,
            "win_rate": (len(wins) / len(self.closed_positions) * 100) if self.closed_positions else 0,
            "winning_trades": len(wins),
            "losing_trades": len(losses),
            "avg_win": sum(p["realized_pnl"] for p in wins) / len(wins) if wins else 0,
            "avg_loss": sum(p["realized_pnl"] for p in losses) / len(losses) if losses else 0,
            "profit_factor": abs(sum(p["realized_pnl"] for p in wins) / sum(p["realized_pnl"] for p in losses)) if losses and sum(p["realized_pnl"] for p in losses) != 0 else 0,
        }


# ============================================================================
# MAIN TRADING ENGINE
# ============================================================================

class OrdinisDemoV051:
    """Ordinis Demo v0.51 - Unified Paper Trading System with Strategy Alignment."""

    def __init__(self):
        """Initialize the trading system."""
        # Logging with version tracking
        self.version = "0.51"
        self.log_manager = LoggingManager()
        self.logger = self.log_manager.get("main")
        self.log_manager.log_session_start()
        self.logger.info(f"Starting Ordinis Demo v{self.version}")

        # Configuration
        self.config = self._load_config()

        # Position tracking
        self.position_tracker = PositionTracker(self.log_manager)

        # Existing holdings
        self.existing_symbols = ["MP", "RUN", "PATH", "UPST", "BAC", "FSLR", "AMD"]

        # Combine with strategy symbols
        config_symbols = list(self.config.get("symbols", {}).keys())
        self.symbols = list(set(self.existing_symbols + config_symbols))

        self.logger.info(f"System initialized with {len(self.symbols)} symbols")
        self.logger.info(f"Existing positions: {', '.join(self.existing_symbols)}")

        # Market data storage
        self.bars: Dict[str, List[Dict]] = defaultdict(list)
        self.latest_quotes: Dict[str, StreamQuote] = {}

        # Signal generation tracking
        self.signal_counts: Dict[str, int] = defaultdict(int)
        self.last_signal_time: Dict[str, datetime] = {}

        # Order management
        self._last_order_time: Dict[str, datetime] = {}
        self._order_cooldown = 60  # seconds between orders per symbol

        # Risk management
        risk_config = self.config.get("risk_management", {})
        self.max_position_pct = risk_config.get("max_position_size_pct", 3.0)
        # DISABLED: Daily loss limit removed per user request
        # self.max_daily_loss_pct = risk_config.get("max_daily_loss_pct", 2.0)
        self.max_daily_loss_pct = float('inf')  # No daily loss limit
        self.max_positions = risk_config.get("max_concurrent_positions", 10)

        # Performance metrics
        self.session_start = datetime.now(UTC)
        self.bars_processed = 0
        self.signals_generated = 0
        self.orders_submitted = 0
        self.orders_filled = 0
        self.orders_rejected = 0

        # Daily tracking
        self.starting_equity = 0.0
        self.current_equity = 0.0
        self.daily_pnl = 0.0
        self.max_equity = 0.0
        self.max_drawdown_pct = 0.0

        # Components
        self.broker: Optional[AlpacaBroker] = None
        self.stream: Optional[MassiveStreamManager] = None
        self.strategy_loader: Optional[StrategyLoader] = None
        self._running = False

    def _load_config(self) -> dict:
        """Load strategy configuration."""
        config_path = Path("configs/strategies/atr_optimized_rsi.yaml")
        if config_path.exists():
            with open(config_path) as f:
                config = yaml.safe_load(f)
                self.logger.info(f"Loaded config: {config.get('strategy', {}).get('name', 'Unknown')}")
                return config
        else:
            self.logger.warning("Config not found, using defaults")
            return self._get_default_config()

    def _get_default_config(self) -> dict:
        """Get default configuration."""
        return {
            "strategy": {
                "name": "Default ATR-RSI Strategy",
                "version": "1.0.0",
            },
            "global_params": {
                "rsi_period": 14,
                "atr_period": 14,
                "default_rsi_oversold": 30,
                "default_rsi_exit": 50,
                "default_rsi_overbought": 70,
                "default_atr_stop_mult": 1.5,
                "default_atr_tp_mult": 2.0,
                "atr_scale_factor": 20,  # Scale factor for minute bars (sqrt of bars per day)
                "existing_position_exit_rsi": 65,  # Higher RSI threshold for existing positions
                "volume_confirmation_ratio": 1.2,  # Volume must be 1.2x average for confirmation
                "require_volume_confirmation": False,  # If True, entries require volume surge
                "signal_cooldown_seconds": 300,  # 5 minute cooldown between signals per symbol
            },
            "risk_management": {
                "max_position_size_pct": 3.0,
                "max_daily_loss_pct": 2.0,
                "max_concurrent_positions": 10,
            },
            # All 88 symbols from the strategy
            "symbols": {
                # Tech stocks
                "AMD": {}, "PLTR": {}, "TSLA": {}, "CRWD": {}, "NET": {},
                "DDOG": {}, "ZS": {}, "OKTA": {}, "TWLO": {}, "PATH": {},
                "BILL": {}, "MDB": {}, "HOOD": {}, "COIN": {}, "RBLX": {},
                "SNAP": {}, "AFRM": {}, "UPST": {}, "SOFI": {}, "SNOW": {},
                "AXON": {}, "VEEV": {}, "TECH": {}, "PODD": {},

                # Energy
                "XOM": {}, "CVX": {}, "XLE": {}, "OXY": {}, "FANG": {},
                "OVV": {}, "CTRA": {}, "AR": {}, "RRC": {}, "PR": {}, "CHK": {},

                # Financials
                "BAC": {}, "WFC": {}, "FITB": {}, "RF": {}, "ALLY": {},
                "CFG": {}, "FRC": {}, "LC": {}, "ZG": {},

                # Airlines
                "DAL": {}, "AAL": {}, "UAL": {}, "ALK": {}, "JBLU": {},

                # Consumer
                "W": {}, "ETSY": {}, "DASH": {}, "ELF": {}, "DKNG": {},
                "CHWY": {}, "EXPE": {}, "HIMS": {}, "CELH": {}, "ABNB": {},
                "MGM": {}, "DKS": {}, "MTCH": {},

                # Industrial
                "CLF": {}, "AA": {}, "MP": {}, "CMC": {}, "ATI": {},
                "XPO": {}, "USFD": {}, "SAIA": {},

                # Real Estate
                "INVH": {}, "OPEN": {}, "VNO": {},

                # Solar/Clean
                "ENPH": {}, "SEDG": {}, "FSLR": {}, "RUN": {}, "GNRC": {},

                # Healthcare
                "DXCM": {}, "EXAS": {}, "ALGN": {}, "DOCS": {},

                # ETFs & Others
                "SPY": {}, "QQQ": {}, "IWM": {}, "SOXS": {}, "EA": {}, "ROKU": {},
            },
        }

    async def initialize(self) -> bool:
        """Initialize broker and data connections."""
        try:
            # Connect to Alpaca
            self.broker = AlpacaBroker(paper=True)
            if not await self.broker.connect():
                self.logger.error("Failed to connect to Alpaca")
                return False

            account = await self.broker.get_account()
            self.starting_equity = float(account.equity)
            self.current_equity = self.starting_equity
            self.max_equity = self.starting_equity

            self.logger.info(f"Connected to Alpaca Paper Trading")
            self.logger.info(f"Account Equity: ${self.starting_equity:,.2f}")
            self.logger.info(f"Account Cash: ${account.cash:,.2f}")

            # Load existing positions
            await self._load_existing_positions()

            # Initialize strategy loader with correct path
            self.strategy_loader = StrategyLoader()
            strategy_path = "../../configs/strategies/atr_optimized_rsi.yaml"
            if not self.strategy_loader.load_strategy(strategy_path):
                self.logger.info("StrategyLoader not using external config, using embedded config instead")
                self.strategy_loader = None  # Disable if not loaded properly

            # Initialize Massive stream
            massive_key = os.environ.get("MASSIVE_API_KEY", "")
            if not massive_key:
                self.logger.error("MASSIVE_API_KEY not set")
                return False

            stream_config = StreamConfig(
                api_key=massive_key,
                reconnect_enabled=True,
                reconnect_delay_seconds=1.0,
                max_reconnect_attempts=10,
            )

            self.stream = MassiveStreamManager(stream_config)

            # Set up handlers
            handler = CallbackStreamHandler(
                on_bar_callback=self._on_bar,
                on_quote_callback=self._on_quote,
                on_status_callback=self._on_status,
                on_error_callback=self._on_error,
            )
            self.stream.add_handler(handler)

            # Connect and subscribe
            await self.stream.connect()
            await self.stream.subscribe(self.symbols)

            self.logger.info(f"Subscribed to {len(self.symbols)} symbols on Massive/Polygon stream")

            return True

        except Exception as e:
            self.log_manager.get("errors").error(f"Initialization failed: {e}", exc_info=True)
            return False

    async def _load_existing_positions(self) -> None:
        """Load existing positions from broker."""
        positions = await self.broker.get_positions()

        loaded_count = 0
        for pos in positions:
            symbol = pos.symbol
            if symbol in self.existing_symbols:
                quantity = int(pos.quantity)
                avg_price = float(pos.avg_entry_price) if hasattr(pos, 'avg_entry_price') else float(pos.market_value) / quantity
                current_price = float(pos.current_price) if hasattr(pos, 'current_price') else avg_price
                market_value = float(pos.market_value)

                self.position_tracker.load_existing_position(
                    symbol, quantity, avg_price, current_price, market_value
                )
                loaded_count += 1

        self.logger.info(f"Loaded {loaded_count} existing positions for management")

    async def run(self) -> None:
        """Main trading loop."""
        if not await self.initialize():
            self.logger.error("Failed to initialize, exiting")
            return

        self._running = True
        self.logger.info("Trading system active - Press Ctrl+C to stop")

        # Start background tasks
        asyncio.create_task(self._performance_monitor())
        asyncio.create_task(self._risk_monitor())

        try:
            while self._running:
                await asyncio.sleep(1)

                # Status updates every minute
                if datetime.now().second == 0:
                    await self._print_status()

        except KeyboardInterrupt:
            self.logger.info("Shutdown signal received")
        except Exception as e:
            self.log_manager.get("errors").error(f"Fatal error: {e}", exc_info=True)
        finally:
            await self.shutdown()

    async def shutdown(self) -> None:
        """Graceful shutdown with reporting."""
        self._running = False

        self.logger.info("Shutting down trading system...")

        if self.stream:
            await self.stream.disconnect()

        # Generate final report
        self._generate_session_report()

        self.logger.info("Ordinis Demo v0.51 shutdown complete")

    async def _on_bar(self, bar: StreamBar) -> None:
        """Process incoming market data bar."""
        self.bars_processed += 1
        symbol = bar.symbol

        # Store bar
        bar_data = {
            "timestamp": bar.timestamp,
            "open": bar.open,
            "high": bar.high,
            "low": bar.low,
            "close": bar.close,
            "volume": bar.volume,
        }
        self.bars[symbol].append(bar_data)

        # Limit history
        if len(self.bars[symbol]) > 100:
            self.bars[symbol] = self.bars[symbol][-100:]

        # Log significant bars
        if symbol in self.symbols and bar.volume > 10000:
            self.log_manager.get("market_data").info(
                f"BAR | {symbol} | O={bar.open:.2f} H={bar.high:.2f} L={bar.low:.2f} "
                f"C={bar.close:.2f} V={bar.volume:,}"
            )

        # Update position if exists
        if symbol in self.position_tracker.positions:
            exit_signal = self.position_tracker.update(symbol, bar.close, bar.volume)
            if exit_signal:
                await self._execute_exit(symbol, exit_signal, bar.close)

        # Check for new signals
        if len(self.bars[symbol]) >= 20:
            await self._check_signals(symbol)

    async def _on_quote(self, quote: StreamQuote) -> None:
        """Process quote update."""
        self.latest_quotes[quote.symbol] = quote

    async def _on_status(self, status: StreamStatus, message: str) -> None:
        """Handle stream status changes."""
        self.log_manager.get("session").info(f"Stream status: {status.name} - {message}")

    async def _on_error(self, error: Exception) -> None:
        """Handle stream errors."""
        self.log_manager.get("errors").error(f"Stream error: {error}")

    async def _check_signals(self, symbol: str) -> None:
        """Check for trading signals using ATR-RSI strategy."""
        df = pd.DataFrame(self.bars[symbol])
        if len(df) < 20:
            return

        # Calculate indicators
        close = df["close"]
        high = df["high"]
        low = df["low"]
        volume = df["volume"]

        # RSI
        rsi = TechnicalIndicators.rsi(close, 14)

        # ATR
        tr = pd.concat(
            [high - low, abs(high - close.shift(1)), abs(low - close.shift(1))], axis=1
        ).max(axis=1)
        atr = tr.rolling(14).mean()

        # Volume analysis
        avg_volume = volume.rolling(20).mean()
        volume_ratio = volume.iloc[-1] / avg_volume.iloc[-1] if avg_volume.iloc[-1] > 0 else 1

        current_rsi = rsi.iloc[-1]
        current_atr = atr.iloc[-1]
        current_price = close.iloc[-1]

        # Regime filter check using StrategyLoader
        if self.strategy_loader:
            try:
                allowed, reason = self.strategy_loader.should_trade(symbol, df)
                if not allowed:
                    # Log at DEBUG level if it's just insufficient data
                    if "Need at least 50 bars" in reason:
                        self.log_manager.get("signals").debug(
                            f"Regime check pending: {symbol} - {reason}"
                        )
                    else:
                        self.log_manager.get("risk").info(
                            f"Blocked by regime gating: {symbol} - {reason}"
                        )
                    return
            except ValueError as e:
                if "Need at least 50 bars" in str(e):
                    # This is expected during startup - log at DEBUG level
                    bars_count = len(df) if df is not None else 0
                    self.log_manager.get("signals").debug(
                        f"Building history: {symbol} has {bars_count}/50 bars"
                    )
                else:
                    self.log_manager.get("risk").warning(f"Regime check failed: {symbol} - {e}")
                return

        # Get config
        symbol_config = self.config.get("symbols", {}).get(symbol, {})
        global_params = self.config.get("global_params", {})

        rsi_oversold = symbol_config.get("rsi_oversold", global_params.get("default_rsi_oversold", 30))
        rsi_exit = symbol_config.get("rsi_exit", global_params.get("default_rsi_exit", 50))
        rsi_overbought = symbol_config.get("rsi_overbought", global_params.get("default_rsi_overbought", 70))

        # Generate signals
        if symbol in self.position_tracker.positions:
            # Exit logic for existing positions
            pos = self.position_tracker.positions[symbol]

            # For existing positions loaded at startup, use more conservative exit threshold
            # This prevents premature exits of positions not opened by this strategy
            if pos.get("is_existing", False):
                existing_exit_rsi = global_params.get("existing_position_exit_rsi", 65)
                if current_rsi > existing_exit_rsi:
                    await self._generate_signal(
                        symbol, "EXIT_RSI", current_price, current_atr,
                        f"RSI exit for existing position ({current_rsi:.1f} > {existing_exit_rsi})"
                    )
            else:
                # Normal exits for positions opened this session
                if current_rsi > rsi_exit:
                    await self._generate_signal(
                        symbol, "EXIT_RSI", current_price, current_atr,
                        f"RSI exit ({current_rsi:.1f} > {rsi_exit})"
                    )
                elif current_rsi > rsi_overbought:
                    await self._generate_signal(
                        symbol, "EXIT_OVERBOUGHT", current_price, current_atr,
                        f"RSI overbought ({current_rsi:.1f} > {rsi_overbought})"
                    )

        elif current_rsi < rsi_oversold:
            # Entry logic
            if len(self.position_tracker.positions) < self.max_positions:
                # Check volume confirmation (configurable)
                volume_threshold = global_params.get("volume_confirmation_ratio", 1.2)
                volume_confirmed = volume_ratio > volume_threshold

                # Optional: require volume confirmation for entries
                if global_params.get("require_volume_confirmation", False) and not volume_confirmed:
                    self.log_manager.get("signals").debug(
                        f"SKIPPED | {symbol} | RSI={current_rsi:.1f} | Insufficient volume ({volume_ratio:.1f}x < {volume_threshold})"
                    )
                    return

                # Check for signal cooldown
                signal_cooldown = global_params.get("signal_cooldown_seconds", 300)
                last_signal = self.last_signal_time.get(symbol)
                if last_signal:
                    elapsed = (datetime.now(UTC) - last_signal).total_seconds()
                    if elapsed < signal_cooldown:
                        return

                reason = f"RSI oversold ({current_rsi:.1f} < {rsi_oversold})"
                if volume_confirmed:
                    reason += f" + Volume surge ({volume_ratio:.1f}x)"

                await self._generate_signal(
                    symbol, "LONG", current_price, current_atr, reason
                )
            else:
                self.log_manager.get("signals").info(
                    f"SKIPPED | {symbol} | RSI={current_rsi:.1f} | Max positions ({self.max_positions})"
                )

    async def _generate_signal(self, symbol: str, signal_type: str, price: float,
                              atr: float, reason: str) -> None:
        """Generate and execute trading signal."""
        self.signals_generated += 1
        self.signal_counts[symbol] += 1
        self.last_signal_time[symbol] = datetime.now(UTC)

        self.log_manager.get("signals").info(
            f"SIGNAL | {symbol} | {signal_type} | Price=${price:.2f} | "
            f"ATR={atr:.2f} | {reason}"
        )

        # Check order cooldown
        last_order = self._last_order_time.get(symbol)
        if last_order:
            elapsed = (datetime.now(UTC) - last_order).total_seconds()
            if elapsed < self._order_cooldown:
                self.log_manager.get("risk").info(
                    f"Order cooldown active for {symbol}: {self._order_cooldown - elapsed:.0f}s remaining"
                )
                return

        # Execute based on signal type
        if signal_type == "LONG":
            await self._execute_long(symbol, price, atr, reason)
        elif signal_type.startswith("EXIT"):
            await self._execute_exit(symbol, signal_type, price)

    async def _execute_long(self, symbol: str, price: float, atr: float, reason: str) -> None:
        """Execute long entry."""
        try:
            # DISABLED: Daily loss limit check removed per user request
            # if self.daily_pnl < 0 and abs(self.daily_pnl / self.starting_equity * 100) > self.max_daily_loss_pct:
            #     self.log_manager.get("risk").warning(
            #         f"Daily loss limit reached: {self.daily_pnl:.2f} ({abs(self.daily_pnl/self.starting_equity*100):.1f}%)"
            #     )
            #     return

            account = await self.broker.get_account()
            equity = float(account.equity)

            # Position sizing
            position_value = equity * (self.max_position_pct / 100)
            quantity = int(position_value / price)

            if quantity <= 0:
                self.log_manager.get("trades").warning(f"Insufficient capital for {symbol}")
                return

            # Submit order
            order = await self.broker.submit_order(
                symbol=symbol,
                side=OrderSide.BUY,
                quantity=Decimal(str(quantity)),
                order_type=OrderType.MARKET,
            )

            self.orders_submitted += 1
            self._last_order_time[symbol] = datetime.now(UTC)

            # Calculate stops
            symbol_config = self.config.get("symbols", {}).get(symbol, {})
            global_params = self.config.get("global_params", {})

            # ATR scaling for minute bars (configurable)
            # For 1-minute bars, we scale by sqrt(390) ~= 20 to approximate daily ATR
            # This can be adjusted based on your timeframe
            atr_scale = global_params.get("atr_scale_factor", 20)  # Default 20 for minute bars
            scaled_atr = atr * atr_scale

            atr_stop = symbol_config.get("atr_stop_mult",
                                        global_params.get("default_atr_stop_mult", 1.5))
            atr_tp = symbol_config.get("atr_tp_mult",
                                      global_params.get("default_atr_tp_mult", 2.0))

            stop_loss = price - (scaled_atr * atr_stop)
            take_profit = price + (scaled_atr * atr_tp)

            # Track position
            self.position_tracker.add_new_position(
                symbol, quantity, price, stop_loss, take_profit, reason
            )

            self.log_manager.get("trades").info(
                f"BUY ORDER | {symbol} | {quantity} shares @ ${price:.2f} | "
                f"Total: ${quantity * price:.2f} | SL: ${stop_loss:.2f} | TP: ${take_profit:.2f}"
            )

            if order:
                self.orders_filled += 1

        except Exception as e:
            self.orders_rejected += 1
            self.log_manager.get("errors").error(f"Error executing long for {symbol}: {e}")

    async def _execute_exit(self, symbol: str, exit_reason: str, price: float) -> None:
        """Execute position exit."""
        if symbol not in self.position_tracker.positions:
            return

        try:
            pos = self.position_tracker.positions[symbol]
            quantity = pos["quantity"]

            # Submit exit order
            order = await self.broker.submit_order(
                symbol=symbol,
                side=OrderSide.SELL,
                quantity=Decimal(str(quantity)),
                order_type=OrderType.MARKET,
            )

            self.orders_submitted += 1
            self._last_order_time[symbol] = datetime.now(UTC)

            # Close position tracking
            closed = self.position_tracker.close(symbol, price, exit_reason)

            self.log_manager.get("trades").info(
                f"SELL ORDER | {symbol} | {quantity} shares @ ${price:.2f} | "
                f"P&L: ${closed['realized_pnl']:.2f} ({closed['realized_pnl_pct']:.1f}%) | "
                f"Reason: {exit_reason}"
            )

            if order:
                self.orders_filled += 1

        except Exception as e:
            self.orders_rejected += 1
            self.log_manager.get("errors").error(f"Error executing exit for {symbol}: {e}")

    async def _performance_monitor(self) -> None:
        """Background task to monitor performance."""
        while self._running:
            await asyncio.sleep(60)

            if self.broker:
                account = await self.broker.get_account()
                self.current_equity = float(account.equity)
                self.daily_pnl = self.current_equity - self.starting_equity

                if self.current_equity > self.max_equity:
                    self.max_equity = self.current_equity

                drawdown = ((self.max_equity - self.current_equity) / self.max_equity * 100) if self.max_equity > 0 else 0
                self.max_drawdown_pct = max(self.max_drawdown_pct, drawdown)

                metrics = self.position_tracker.get_metrics()

                self.log_manager.get("performance").info(
                    f"METRICS | Equity: ${self.current_equity:,.2f} | "
                    f"Daily P&L: ${self.daily_pnl:,.2f} ({self.daily_pnl/self.starting_equity*100:.1f}%) | "
                    f"Drawdown: {drawdown:.1f}% | Positions: {metrics['open_positions']} | "
                    f"Closed: {metrics['closed_trades']} | Win Rate: {metrics['win_rate']:.1f}%"
                )

    async def _risk_monitor(self) -> None:
        """Background task to monitor risk limits."""
        while self._running:
            await asyncio.sleep(30)

            # DISABLED: Daily loss limit monitoring removed per user request
            # if self.daily_pnl < 0:
            #     loss_pct = abs(self.daily_pnl / self.starting_equity * 100)
            #     if loss_pct > self.max_daily_loss_pct * 0.8:  # 80% warning
            #         self.log_manager.get("risk").warning(
            #             f"Approaching daily loss limit: ${self.daily_pnl:.2f} ({loss_pct:.1f}% of {self.max_daily_loss_pct}%)"
            #         )

    async def _print_status(self) -> None:
        """Print periodic status update."""
        if not self.broker:
            return

        account = await self.broker.get_account()
        metrics = self.position_tracker.get_metrics()

        self.logger.info("-" * 70)
        self.logger.info(
            f"STATUS | Equity: ${account.equity:,.2f} | Cash: ${account.cash:,.2f} | "
            f"Positions: {metrics['open_positions']} | Daily P&L: ${self.daily_pnl:,.2f}"
        )

        if self.position_tracker.positions:
            positions_summary = []
            for symbol, pos in list(self.position_tracker.positions.items())[:5]:
                positions_summary.append(f"{symbol}({pos['unrealized_pnl_pct']:.1f}%)")

            if len(self.position_tracker.positions) > 5:
                positions_summary.append(f"...+{len(self.position_tracker.positions) - 5} more")

            self.logger.info(f"Positions: {', '.join(positions_summary)}")

    def _generate_session_report(self) -> None:
        """Generate comprehensive session report."""
        metrics = self.position_tracker.get_metrics()
        duration = (datetime.now(UTC) - self.session_start).total_seconds() / 60

        report = f"""
{'=' * 80}
ORDINIS DEMO v0.51 - SESSION REPORT
{'=' * 80}
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Session Duration: {duration:.1f} minutes

ACCOUNT SUMMARY:
  Starting Equity: ${self.starting_equity:,.2f}
  Final Equity: ${self.current_equity:,.2f}
  Daily P&L: ${self.daily_pnl:,.2f} ({self.daily_pnl/self.starting_equity*100:.2f}%)
  Max Drawdown: {self.max_drawdown_pct:.2f}%

ACTIVITY METRICS:
  Bars Processed: {self.bars_processed:,}
  Signals Generated: {self.signals_generated}
  Orders Submitted: {self.orders_submitted}
  Orders Filled: {self.orders_filled}
  Orders Rejected: {self.orders_rejected}

POSITION METRICS:
  Open Positions: {metrics['open_positions']}
  Closed Trades: {metrics['closed_trades']}
  Total Realized P&L: ${metrics['total_realized_pnl']:.2f}
  Total Unrealized P&L: ${metrics['total_unrealized_pnl']:.2f}

TRADING PERFORMANCE:
  Win Rate: {metrics['win_rate']:.1f}%
  Winning Trades: {metrics['winning_trades']}
  Losing Trades: {metrics['losing_trades']}
  Average Win: ${metrics['avg_win']:.2f}
  Average Loss: ${metrics['avg_loss']:.2f}
  Profit Factor: {metrics['profit_factor']:.2f}

LOG FILES:
  Main: logs/ordinis_demo_v051.log
  Trades: logs/trades.log
  Signals: logs/signals.log
  Positions: logs/positions.log
  Performance: logs/performance.log
  Archive: {self.log_manager.archive_dir}

{'=' * 80}
"""

        print(report)

        # Save report
        report_path = self.log_manager.archive_dir / "session_report.txt"
        with open(report_path, "w") as f:
            f.write(report)

        # Save JSON version
        report_data = {
            "version": "0.51",
            "session_start": self.session_start.isoformat(),
            "duration_minutes": duration,
            "account": {
                "starting_equity": self.starting_equity,
                "final_equity": self.current_equity,
                "daily_pnl": self.daily_pnl,
                "max_drawdown_pct": self.max_drawdown_pct,
            },
            "activity": {
                "bars_processed": self.bars_processed,
                "signals_generated": self.signals_generated,
                "orders_submitted": self.orders_submitted,
                "orders_filled": self.orders_filled,
                "orders_rejected": self.orders_rejected,
            },
            "performance": metrics,
            "symbols_tracked": self.symbols,
            "archive_directory": str(self.log_manager.archive_dir),
        }

        json_path = self.log_manager.archive_dir / "session_report.json"
        with open(json_path, "w") as f:
            json.dump(report_data, f, indent=2, default=str)

        self.log_manager.get("session").info(f"Session report saved to {self.log_manager.archive_dir}")


# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

async def main():
    """Main entry point for Ordinis Demo v0.51."""
    print()
    print("=" * 80)
    print("ORDINIS DEMO v0.51 - LIVE PAPER TRADING WITH STRATEGY ALIGNMENT")
    print("=" * 80)
    print()

    # Check environment
    env_ok = True
    for var in ["MASSIVE_API_KEY", "APCA_API_KEY_ID", "APCA_API_SECRET_KEY"]:
        value = os.environ.get(var)
        if value:
            print(f"  [{var}]: {value[:4]}...{value[-4:]}")
        else:
            print(f"  [{var}]: NOT SET")
            env_ok = False

    if not env_ok:
        print("\nERROR: Missing required environment variables")
        print("Set them using PowerShell:")
        print('[System.Environment]::SetEnvironmentVariable("VAR_NAME", "value", "User")')
        return

    print()

    # Run the demo
    demo = OrdinisDemoV051()
    await demo.run()


if __name__ == "__main__":
    asyncio.run(main())