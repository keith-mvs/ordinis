Ordinis System Integration Interfaces
=====================================

**Overview:** This specification defines core **Python Protocol** interfaces for key components of the Ordinis event-driven trading system. Each interface (port) includes a brief purpose, method signatures with type hints, and notes on behavior (synchronous vs. asynchronous operation, mutability, idempotency). These interfaces follow **Clean Architecture** principles, decoupling the system’s core logic from implementation details. In an event-driven design, the `EventBus` serves as the backbone for communication between modules, promoting loose coupling and extensibility. The use of Protocols (PEP 544) allows different modules (adapters) to implement or consume these interfaces interchangeably, enabling unit testing and easy substitution (e.g. using a simulated engine in place of a live one) in line with dependency inversion.
Interface Definitions
---------------------

### EventBus Protocol

This interface manages publish/subscribe messaging between components, enabling an **event-driven architecture** (producers and consumers are decoupled). It should deliver events to all subscribed handlers, typically in a non-blocking manner (e.g. using an internal queue or async loop). Subscribers may register for specific event types. The EventBus itself is usually a singleton or application-wide service. **Idempotency:** Adding or removing the same handler multiple times has no extra effect (duplicate subscriptions are ignored). Handlers are generally invoked synchronously in order or on a background thread/loop (implementation may vary, but callers of `publish` should not block on handler execution).

`from typing import Protocol, Type, Callable, TypeVarT = TypeVar('T', bound='Event')  class Event(Protocol):    """Base class for events (payload marker)."""     type: str  # event type name or category  class EventBus(Protocol):    """Pub/sub event bus for decoupling components via events."""     def publish(self, event: Event) -> None:        """Publish an event to all subscribers of its type.        Non-blocking fire-and-forget: returns immediately after queuing the event.        Handlers may run in background or synchronously (implementation-defined)."""         ...    def subscribe(self, event_type: Type[T], handler: Callable[[T], None]) -> None:        """Subscribe a handler to events of the given type T.        The handler will be called for each published event of that type (or subtype).        Idempotent: registering the same handler twice has no effect."""         ...    def unsubscribe(self, event_type: Type[T], handler: Callable[[T], None]) -> None:        """Unsubscribe a previously registered handler from the event type.        Idempotent: no error if the handler was not subscribed."""         ...`

### BrokerAdapter Protocol

An interface to an external brokerage/trading API (e.g. Alpaca, Interactive Brokers). It abstracts operations like placing and canceling orders, so that the core system doesn’t depend on a specific broker SDK. **Async vs Sync:** Network calls to a broker can be slow, so methods are defined as `async` to allow non-blocking IO. Implementations will perform HTTP/API calls. **Idempotency:** Canceling an order is idempotent (canceling an already-filled or already-canceled order has no adverse effect). Placing an order is _not_ idempotent – calling `submit_order` twice will place duplicate orders (the system should ensure each order is only sent once).

`from typing import Protocol  class BrokerAdapter(Protocol):    """Adapter for executing trades via an external broker API."""     async def submit_order(self, order: 'Order') -> str:        """Place a new order with the broker.         Returns a broker-assigned order ID on success.        (Network I/O, so should be awaited. Not idempotent if called repeatedly.)"""         ...    async def cancel_order(self, order_id: str) -> None:        """Request cancellation of an existing order by ID.        Safe to call multiple times; has no effect if order is already closed."""         ...    async def get_order_status(self, order_id: str) -> 'OrderStatus':        """Retrieve the current status of an order (e.g., pending, filled, canceled).        May be polled if no webhook/event from broker. Returns a status enum or object."""         ...`

_Note:_ In a live trading deployment, a concrete adapter (e.g. `AlpacaBrokerAdapter`) would implement this interface and handle authentication, REST endpoints, etc. The system’s live ExecutionEngine would use this adapter to route orders to the broker (for example, orders approved by strategies are sent to Alpaca’s API).

### ExecutionEngine Protocol

The ExecutionEngine defines how orders are executed and transformed into trade **fills**. It acts as the abstraction for order handling in different environments (backtest vs live). In a **backtesting** context, an ExecutionEngine implementation will simulate order fills (using a FillModel) and publish fill events. In a **live** context, an ExecutionEngine might forward orders to a BrokerAdapter and rely on broker callbacks/events for fills. The interface ensures strategies and other components can submit orders uniformly without knowing the execution details. **Behavior:** This interface typically processes orders asynchronously with respect to the strategy: calling `execute_order` will _trigger_ execution but not necessarily block until completion (fills are delivered via events or separate callbacks). Implementations should ensure thread-safety if used from multiple signal/strategy sources. **Idempotency:** Each call to `execute_order` is treated as a distinct request (the same order should not be executed twice unless intended).

`from typing import Protocol  class ExecutionEngine(Protocol):    """Engine that processes orders and produces fills (simulation or live execution)."""     def execute_order(self, order: 'Order') -> None:        """Submit an order for execution. In backtesting, this enqueues the order into the         simulator; in live trading, this forwards the order to a broker (via BrokerAdapter).        Non-blocking: returns immediately. Fills will be reported via events or callbacks."""         ...    def cancel_order(self, order_id: str) -> None:        """Cancel a previously submitted order if still possible.        In live trading, forwards to broker; in simulation, removes or marks the order as canceled.        Idempotent: does nothing if order is already filled or canceled."""         ...`

_Note:_ The ExecutionEngine implementations ensure that after `execute_order` is called, subsequent fill/cancel events are generated. For example, the backtest engine will generate fill events (via EventBus) when an order is matched in simulation, whereas a live engine might emit fill events upon receiving confirmations from the broker.

### FillModel Protocol

The FillModel encapsulates the logic of how orders get filled in a simulation or backtest environment. Different fill models can simulate varying market conditions (instant fill, partial fills over time, slippage impact, etc.). This interface provides a method to calculate fill outcomes for a given order given the current market state. **Determinism:** FillModel methods should be **pure** functions with no side-effects (they shouldn’t modify global state, only compute fill results). Given the same inputs (order and market data at a time), they should return the same result (idempotent for identical inputs). **Mutability:** Any state about an order’s remaining quantity should be tracked outside the FillModel (e.g., in the ExecutionEngine), or the FillModel may return partial fills and let the engine call it again for the remaining quantity on subsequent market events.

`from typing import Protocol  class FillModel(Protocol):    """Strategy for simulating order fills (for backtesting/paper trading)."""     def simulate_fill(self, order: 'Order', market_data: 'MarketData') -> 'FillEvent':        """Determine how an order would be filled given current market conditions.        Returns a FillEvent with executed quantity and price (and possibly remaining quantity).        This may simulate slippage and partial fills based on market_data (e.g. bid/ask, volume).        - Should not modify the Order; just compute outcome.        - If order is not fully filled, the remaining quantity stays open for future simulation calls."""         ...`

_Note:_ `MarketData` here could be a snapshot of prices/order book at the time of execution or any context needed (could be a simple price tick or a more complex market state object). The `FillEvent` returned would include details like filled quantity, fill price, and maybe a reference to the order. **Example:** A market order might fill immediately at the current price, whereas a limit order might return no fill if price hasn’t reached the limit; a large order might return a partial fill if limited by volume. Different implementations (e.g., `ImmediateFillModel`, `PartialFillModel`) can be swapped in to change simulation realism.

### CostModel Protocol

The CostModel calculates **transaction costs** associated with trades, such as commissions, fees, or slippage-based price impact if not handled in FillModel. This interface allows the trading engine to estimate and account for costs per trade uniformly. It takes trade execution details and returns a cost value. **Statelessness:** Cost calculations should be pure (no internal state), depending only on input parameters (order/fill details, perhaps market conditions). **Units:** The cost returned could be in absolute currency terms or as a percentage/point impact, depending on usage. Typically, the ExecutionEngine or Portfolio will use this to adjust P/L calculations or enforce strategy cost constraints.

`from typing import Protocol  class CostModel(Protocol):    """Defines how trading costs (commission, fees, slippage) are calculated."""     def calculate_cost(self, order: 'Order', fill: 'FillEvent') -> float:        """Compute the transaction cost for a given fill.        E.g., commission based on traded volume, exchange fees, or slippage cost.        Returns a cost value (in same currency as the trade P&L impact).        - Should not modify any input state.        - Should return 0 if no cost applicable.        """         ...`

_Note:_ In practice, a CostModel might be configured with fee schedules or slippage parameters at initialization. For example, an implementation might have a per-share commission rate or a tiered fee structure. By abstracting this in a protocol, one can plug in different cost models (zero-cost for ideal backtests, vs realistic brokerage fees for more accurate simulation).

### RiskPolicy Protocol

The RiskPolicy interface defines the contract for risk management checks that must be satisfied before executing trades. It encapsulates rules about exposures, leverage, drawdown limits, etc., decoupling these checks from strategy logic. Implementations can either block trades that violate risk or adjust them (though typically they act as a **gatekeeper** that either approves or rejects actions). **Sync vs Async:** These checks are usually fast (pure computations on current portfolio and proposed trade) and thus are synchronous. **Idempotency:** Given the same input state (portfolio and signal/order), the result should be the same – no side effects (calling it doesn’t alter portfolio or order, it just evaluates). The interface can provide checks at both the **signal level** (should we even consider this signal given risk?) and the **order level** (final sanity check on size/position limits).

`from typing import Protocol  class RiskPolicy(Protocol):    """Defines risk management rules to approve or reject trading actions."""     def approve_signal(self, signal: 'Signal', portfolio: 'Portfolio') -> bool:        """Evaluate a raw trading signal against risk criteria (pre-trade check).        Returns True if the signal is safe to act on (e.g., not opening excessive risk),        False if the signal should be ignored due to risk limits."""         ...    def approve_order(self, order: 'Order', portfolio: 'Portfolio') -> bool:        """Evaluate a proposed Order (with size) against portfolio risk limits.        Returns True if the order is allowed (within exposure, leverage, drawdown limits, etc.),        or False if it violates risk policy (order should be blocked or reduced).        """         ...`

_Note:_ In a live trading flow, **RiskGuard** (the risk management module) would implement this interface. For example, it may prevent new long signals if the portfolio’s sector exposure is too high, or reject an order that would exceed a max position size. By using a `RiskPolicy` interface, the core strategy engine can invoke risk checks without knowing the details (Clean Architecture principle: the strategy or signal generator depends on an abstraction, and RiskGuard provides the implementation).
Module-to-Interface Mapping
---------------------------

The following table maps each major Ordinis module to the interface(s) it implements (provides) or consumes. In Clean Architecture terms, each module acts as an **adapter** or a client to these **ports**, connecting the module to the rest of the system:

| **Module (Engine Layer)** | **Implements (Provides)**                         | **Consumes (Requires)**                                     |
| ------------------------- | ------------------------------------------------- | ----------------------------------------------------------- |
| **SignalCore** (Signals)  | _N/A_ (uses core Strategy API)                    | **EventBus** (for data & signal events)                     |
| **ProofBench** (Backtest) | **ExecutionEngine** (simulated)                   | **EventBus** (orders & fills), **FillModel**, **CostModel** |
| **RiskGuard** (Risk)      | **RiskPolicy**                                    | **EventBus** (for signal/order events)                      |
| **OptionsCore** (Options) | **FillModel**, **CostModel** _(options-specific)_ | **EventBus** (option data events)*                          |
| **CortexRAG** (RAG)       | _N/A_ (internal services)                         | **EventBus** (for query/knowledge events)*                  |

_(Modules marked with ***** interface usage are optional or context-specific: for instance, OptionsCore might produce its own events or integrate via the EventBus when needed, and CortexRAG’s integration via EventBus would depend on how user queries are handled.)_
Module Roles and Integration
----------------------------

* **SignalCore:** _Signal generation engine._ This module consumes market data (historical or real-time) and produces trading signals. It subscribes to **market data events** via the EventBus and publishes **Signal events** for downstream consumers. SignalCore itself doesn’t implement a specific interface listed above; instead, it acts as a producer/consumer on the EventBus and works within the Strategy framework (generating `Signal` objects for strategies). In the architecture, SignalCore is an interchangeable component for different signal-generation models, and the EventBus decouples it from data sources or listeners.

* **ProofBench:** _Backtesting engine._ ProofBench is the concrete implementation of the **ExecutionEngine** interface for simulations. When a strategy submits an Order (either by direct call or via an Order event), ProofBench processes it using a **FillModel** to simulate realistic execution (e.g. accounting for slippage and partial fills) and a **CostModel** to apply commissions or fees. It publishes **fill events** (and possibly order status events) to the EventBus for other components (like a Portfolio tracker or Monitoring) to consume. By conforming to the ExecutionEngine protocol, ProofBench can be swapped with a live trading engine without changing the strategy code. This design follows Clean Architecture’s principle of replacing external interactions: for example, in backtests ProofBench generates fills internally, while in live trading the engine would route orders to a broker and receive real fills. ProofBench ensures the backtesting flow is **event-driven** (sequence of Data -> Signal -> Order -> Fill events).

* **RiskGuard:** _Risk management module._ RiskGuard implements the **RiskPolicy** interface, serving as the system’s risk gatekeeper. It evaluates signals and orders against predefined risk rules (e.g. max position size, portfolio VaR limits, drawdown constraints). In practice, RiskGuard subscribes to **Signal events** (or is invoked in the strategy pipeline) to **approve or reject signals** before they convert into orders. It may also check final orders before execution. By abiding by the RiskPolicy protocol, RiskGuard’s logic is abstracted – the trading workflow calls `approve_signal`/`approve_order` without needing to know how RiskGuard computes risk. This separation makes it easy to modify risk rules or swap out risk modules (for example, a more advanced RiskGuard could be used in the future) without affecting strategy code. RiskGuard also uses the EventBus to listen for relevant events (like fills or portfolio updates) to update its internal state (e.g., current exposure) and possibly to publish risk alerts if limits are breached.

* **OptionsCore:** _Options analytics engine._ OptionsCore provides domain-specific capabilities for options trading – such as options pricing models, Greeks calculation, and multi-leg strategy analysis. It implements **FillModel** and **CostModel** interfaces specialized for options, because filling an options order or computing its transaction cost might require option-specific logic (e.g., accounting for multi-leg spreads or options liquidity). For instance, OptionsCore might supply a custom fill simulator that models partial fills based on option market volatility, and a cost model that includes per-contract fees. In the event-driven system, OptionsCore can integrate via the EventBus as well: it could subscribe to **options market data events** and publish **Option signal events** or valuation updates for other components. While not explicitly a producer of orders on its own, it serves the strategy layer by providing the necessary calculations and can be thought of as an extension of the ExecutionEngine for the options asset class (ensuring that backtesting and analysis of options strategies are as accurate as for other assets).

* **CortexRAG:** _Retrieval-Augmented Generation module._ This component uses an LLM with a knowledge base to answer questions or provide insights on trading strategies and data. CortexRAG doesn’t directly participate in the trading loop (signals/orders), so it does not implement a trading interface like ExecutionEngine or RiskPolicy. Instead, it functions as a **service module** that can be invoked for research or user queries. In terms of integration, CortexRAG can consume the **EventBus** by listening for query events (for example, if the user asks a question in the CLI or dashboard, an event could trigger CortexRAG to retrieve relevant info and respond). It may publish events or messages with its answers or log them for the user interface. This decoupling via the EventBus means CortexRAG can operate asynchronously, without blocking trading operations. Although CortexRAG stands somewhat aside from the core trading execution pipeline, treating it as a port/adapter module maintains architectural consistency — it can be added or removed without impacting the trading system, aligning with the modularity and extensibility goals of Ordinis.

**Clean Architecture Alignment:** By defining these protocols and mapping modules to them, Ordinis ensures a clear separation of concerns. The core logic (strategies, signal generation, portfolio updates) depends only on the **interfaces (ports)**, not on concrete implementations. For example, a strategy does not care if the ExecutionEngine is a simulator or a live broker connector – it just calls `execute_order` on the interface. This inversion of dependencies allows swapping components (e.g., ProofBench vs. live engine, different RiskPolicy rules, different data feeds) with minimal code changes. The EventBus further supports this by promoting an **event-driven design** where components communicate through events rather than direct calls, making the system **loosely coupled and reactive** to new data or actions. Overall, this architecture makes the trading system robust, testable, and adaptable to new requirements, while each module clearly knows its role and the interface contracts it must uphold.

 

**Sources:**

* Ordinis Architecture Documentation – core components and design principles

* Ordinis Data & Trading Flows – illustrated backtesting and live trading event flow
