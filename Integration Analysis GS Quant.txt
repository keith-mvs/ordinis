Integration Analysis: GS-Quant Adapter & BollingerRSIConfluenceStrategy
Executive Summary
The newly created gs_quant_adapter.py and BollingerRSIConfluenceStrategy introduce significant functional overlap with existing components. While the implementations are clean and well-tested, integration requires addressing 5 areas of duplication and 3 architectural considerations.

1. DUPLICATED FUNCTIONALITY
1.1 Technical Indicator Implementations (HIGH PRIORITY)
Function	New Location	Existing Locations	Status
rsi()	ordinis.quant.gs_quant_adapter	ordinis.engines.signalcore.features.technical.TechnicalIndicators.rsi<br>ordinis.analysis.technical.indicators.oscillators.Oscillators.rsi	3 implementations
bollinger_bands()	ordinis.quant.gs_quant_adapter	ordinis.engines.signalcore.features.technical.TechnicalIndicators.bollinger_bands<br>ordinis.analysis.technical.indicators.volatility.VolatilityIndicators.bollinger_bands	3 implementations
macd()	ordinis.quant.gs_quant_adapter	ordinis.engines.signalcore.features.technical.TechnicalIndicators.macd	2 implementations
moving_average() / sma()	ordinis.quant.gs_quant_adapter	ordinis.engines.signalcore.features.technical.TechnicalIndicators.sma	2 implementations
volatility()	ordinis.quant.gs_quant_adapter	ordinis.analysis.technical.indicators.volatility.VolatilityIndicators.historical_volatility	2 implementations
zscores() / z_score()	ordinis.quant.gs_quant_adapter	ordinis.engines.signalcore.features.technical.TechnicalIndicators.z_score	2 implementations
Implementation Differences:

gs_quant_adapter: Uses Window class with ramp-up handling, returns pd.Series with trimmed NaN values
TechnicalIndicators: Simple pandas rolling, returns full series with leading NaNs
Oscillators/VolatilityIndicators: Feature-rich with signal generation, dataclasses for outputs
1.2 Strategy Duplication (MEDIUM PRIORITY)
New Strategy	Existing Similar Strategies
BollingerRSIConfluenceStrategy	BollingerBandsStrategy + RSIMeanReversionStrategy (separate)<br>ADXFilteredRSIStrategy (RSI with filter)<br>MultiSignalConfluenceModel (signalcore model)
The new strategy is essentially a combination of two existing strategies with the added benefit of using gs-quant functions.

1.3 Risk Metrics Duplication
New Function	Existing Location
sharpe_ratio()	ordinis.engines.riskguard.models.gsquant_risk.GSQuantRiskManager._calculate_risk_local<br>ordinis.engines.proofbench.analytics.performance.PerformanceMetrics
max_drawdown()	ordinis.engines.riskguard.models.gsquant_risk.GSQuantRiskManager._calculate_risk_local<br>ordinis.engines.proofbench.analytics.performance
beta()	ordinis.engines.riskguard.models.gsquant_risk.GSQuantRiskManager._calculate_risk_local
correlation()	Various inline calculations throughout codebase
2. ARCHITECTURAL INCONSISTENCIES
2.1 Module Organization Conflict
Issue: Technical indicators now exist in 3 separate locations with different APIs:

Class-based (TechnicalIndicators.rsi())
Standalone functions (ordinis.quant.rsi())
Feature-rich classes (Oscillators.rsi() with OscillatorSignal)
2.2 Strategy vs Model Distinction
Layer	Pattern	Example
application/strategies/	BaseStrategy with async generate_signal()	BollingerRSIConfluenceStrategy (NEW)
engines/signalcore/models/	Model with async generate() returning Signal	BollingerBandsModel, RSIMeanReversionModel
Issue: BollingerRSIConfluenceStrategy bypasses the SignalCore model registry by directly calculating indicators, rather than composing existing models.

2.3 gs-quant Integration Paths
Two separate gs-quant integrations now exist:

Module	Purpose	API Dependency
ordinis.quant.gs_quant_adapter	Standalone timeseries functions	None (pure numpy/pandas)
ordinis.engines.riskguard.models.gsquant_risk	Portfolio risk with optional API	Optional GS Marquee API
3. RECOMMENDATIONS
3.1 Consolidate Technical Indicators (RECOMMENDED)
Create a unified technical analysis module that delegates to gs-quant functions:

3.2 Update Existing Models to Use gs_quant_adapter
Modify BollingerBandsModel and RSIMeanReversionModel to use:

instead of:

3.3 Register BollingerRSIConfluenceStrategy in init.py
The new strategy was created but not added to the strategies __init__.py exports:

3.4 Create SignalCore Model Wrapper
Instead of a standalone strategy, create a corresponding SignalCore model:

4. POTENTIAL CONFLICTS
4.1 Parameter Naming Inconsistency
gs_quant_adapter	Existing Code
w (window)	window, period
k (std devs)	num_std, std_dev, bb_std
returns_type	N/A
4.2 Return Value Differences
Function	gs_quant_adapter Returns	Existing Returns
bollinger_bands()	pd.DataFrame with columns	tuple[pd.Series, pd.Series, pd.Series]
rsi()	pd.Series (trimmed)	pd.Series (with NaN)
volatility()	pd.Series (annualized %)	Varies by implementation
5. FILES AFFECTED
Must Update for Integration:
src/ordinis/application/strategies/__init__.py - Add export
src/ordinis/engines/signalcore/features/technical.py - Consider deprecation
src/ordinis/analysis/technical/indicators/ - Consider consolidation
Optional Refactoring Targets:
src/ordinis/engines/signalcore/models/bollinger_bands.py
src/ordinis/engines/signalcore/models/rsi_mean_reversion.py
src/ordinis/engines/signalcore/models/macd.py
6. SUMMARY
Aspect	Finding	Severity
Technical indicator duplication	3 implementations of RSI, BB	High
Strategy-model architecture	New strategy bypasses model layer	Medium
Export missing	BollingerRSIConfluenceStrategy not exported	High
Parameter naming	Inconsistent across modules	Low
Risk metric duplication	Sharpe/drawdown in 3 places	Medium
gs-quant integration	Two separate paths (timeseries vs API)	Low - by design
Recommendation: The gs_quant_adapter is valuable as a canonical source for indicator calculations. Refactor existing models and strategies to use it, deprecating duplicate implementations.
